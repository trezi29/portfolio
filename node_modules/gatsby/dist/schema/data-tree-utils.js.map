{"version":3,"sources":["../../src/schema/data-tree-utils.js"],"names":["_","require","flatten","typeOf","createKey","typeConflictReporter","INVALID_VALUE","Symbol","isDefined","v","isEmptyObjectOrArray","obj","isDate","isObject","isEmpty","every","value","key","isScalar","val","Date","extractTypes","isArray","uniqueTypes","uniq","filter","map","item","type","sort","join","arrayTypes","getExampleScalarFromArray","reduce","values","nextValue","isNumber","isInteger","extractFromEntries","entries","selector","entriesOfUniqueType","uniqBy","entry","length","addConflict","exampleValue","concatanedItems","concat","includes","extractFromArrays","isPlainObject","extractFieldExamples","filteredItems","flattenEntries","parent","arrayItemExample","nodes","allKeys","keys","pickBy","zipObject","nextSelector","nodeWithValues","node","buildFieldEnumValues","enumValues","getExampleValues","arg","maxDepth","safe","delimiter","Object","forEach","field","extractFieldNames","typeExampleValues","clearTypeExampleValues","clearConflicts","getNodesAndTypeFromArg","internal","isString","module","exports"],"mappings":"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","file":"data-tree-utils.js","sourcesContent":["// @flow\nconst _ = require(`lodash`)\nconst flatten = require(`flat`)\nconst typeOf = require(`type-of`)\n\nconst createKey = require(`./create-key`)\nconst { typeConflictReporter } = require(`./type-conflict-reporter`)\n\nconst INVALID_VALUE = Symbol(`INVALID_VALUE`)\nconst isDefined = v => v != null\n\nconst isEmptyObjectOrArray = (obj: any): boolean => {\n  if (obj === INVALID_VALUE) {\n    return true\n  } else if (_.isDate(obj)) {\n    return false\n    // Simple \"is object empty\" check.\n  } else if (_.isObject(obj) && _.isEmpty(obj)) {\n    return true\n  } else if (_.isObject(obj)) {\n    return _.every(obj, (value, key) => {\n      if (!isDefined(value)) {\n        return true\n      } else if (_.isObject(value)) {\n        return isEmptyObjectOrArray(value)\n      } else {\n        return false\n      }\n    })\n  }\n  return false\n}\n\nconst isScalar = val => !_.isObject(val) || val instanceof Date\n\nconst extractTypes = value => {\n  if (_.isArray(value)) {\n    const uniqueTypes = _.uniq(\n      value.filter(isDefined).map(item => extractTypes(item).type)\n    ).sort()\n    return {\n      type: `array<${uniqueTypes.join(`|`)}>`,\n      arrayTypes: uniqueTypes,\n    }\n  } else {\n    const type = typeOf(value)\n    return {\n      type,\n      arrayTypes: [],\n    }\n  }\n}\n\nconst getExampleScalarFromArray = values =>\n  _.reduce(\n    values,\n    (value, nextValue) => {\n      // Prefer floats over ints as they're more specific.\n      if (value && _.isNumber(value) && !_.isInteger(value)) {\n        return value\n      } else if (value === null) {\n        return nextValue\n      } else {\n        return value\n      }\n    },\n    null\n  )\n\nconst extractFromEntries = (entries, selector, key = null) => {\n  const entriesOfUniqueType = _.uniqBy(entries, entry => entry.type)\n\n  if (entriesOfUniqueType.length == 0) {\n    // skip if no defined types\n    return null\n  } else if (\n    entriesOfUniqueType.length > 1 ||\n    entriesOfUniqueType[0].arrayTypes.length > 1\n  ) {\n    // there is multiple types or array of multiple types\n    if (selector) {\n      typeConflictReporter.addConflict(selector, entriesOfUniqueType)\n    }\n    return INVALID_VALUE\n  }\n\n  // Now we have entries of single type, we can merge them\n  const values = entries.map(entry => entry.value)\n\n  const exampleValue = entriesOfUniqueType[0].value\n  if (isScalar(exampleValue)) {\n    return getExampleScalarFromArray(values)\n  } else if (_.isObject(exampleValue)) {\n    if (_.isArray(exampleValue)) {\n      const concatanedItems = _.concat(...values)\n      // Linked node arrays don't get reduced further as we\n      // want to preserve all the linked node types.\n      if (_.includes(key, `___NODE`)) {\n        return concatanedItems\n      }\n\n      return extractFromArrays(concatanedItems, entries, selector)\n    } else if (_.isPlainObject(exampleValue)) {\n      return extractFieldExamples(values, selector)\n    }\n  }\n  // unsuported object\n  return INVALID_VALUE\n}\n\nconst extractFromArrays = (values, entries, selector) => {\n  const filteredItems = values.filter(isDefined)\n  if (filteredItems.length === 0) {\n    return null\n  }\n  if (isScalar(filteredItems[0])) {\n    return [getExampleScalarFromArray(filteredItems)]\n  }\n\n  const flattenEntries = _.flatten(\n    entries.map(entry =>\n      entry.value.map(value => {\n        return {\n          value,\n          parent: entry.parent,\n          ...extractTypes(value),\n        }\n      })\n    )\n  )\n\n  const arrayItemExample = extractFromEntries(flattenEntries, `${selector}[]`)\n  if (!isDefined(arrayItemExample) || arrayItemExample === INVALID_VALUE) {\n    return INVALID_VALUE\n  }\n\n  return [arrayItemExample]\n}\n\n/**\n * Takes an array of source nodes and returns a pristine\n * example that can be used to infer types.\n *\n * Arrays are flattened to either: `null` for empty or sparse arrays or a\n * an array of a sigle merged example. e.g:\n *\n *  - ['red'], ['blue', 'yellow'] -> ['red']\n *  - [{ color: 'red'}, { color: 'blue', ht: 5 }] -> [{ color: 'red', ht: 5 }]\n *\n * @param {*Nodes} args\n */\nconst extractFieldExamples = (nodes: object[], selector: string) => {\n  // get list of keys in all nodes\n  const allKeys = _.uniq(_.flatten(nodes.map(_.keys)))\n\n  return _.pickBy(\n    _.zipObject(\n      allKeys,\n      allKeys.map(key => {\n        const nextSelector = selector && `${selector}.${key}`\n\n        const nodeWithValues = nodes.filter(node => {\n          if (!node) return false\n\n          const value = node[key]\n          if (_.isObject(value)) {\n            return !isEmptyObjectOrArray(value)\n          } else {\n            return isDefined(value)\n          }\n        })\n\n        // we want to keep track of nodes as we need it to get origin of data\n        const entries = nodeWithValues.map(node => {\n          const value = node[key]\n          return {\n            value,\n            parent: node,\n            ...extractTypes(value),\n          }\n        })\n\n        return extractFromEntries(entries, nextSelector, key)\n      })\n    ),\n    isDefined\n  )\n}\n\nconst buildFieldEnumValues = arg => {\n  const enumValues = {}\n  const values = flatten(getExampleValues(arg), {\n    maxDepth: 3,\n    safe: true, // don't flatten arrays.\n    delimiter: `___`,\n  })\n  Object.keys(values).forEach(field => {\n    if (values[field] == null) return\n    enumValues[createKey(field)] = { field }\n  })\n\n  return enumValues\n}\n\n// extract a list of field names\n// nested objects get flattened to \"outer___inner\" which will be converted back to\n// \"outer.inner\" by run-sift\nconst extractFieldNames = arg => {\n  const values = flatten(getExampleValues(arg), {\n    maxDepth: 3,\n    safe: true, // don't flatten arrays.\n    delimiter: `___`,\n  })\n\n  return Object.keys(values)\n}\n\nlet typeExampleValues = {}\n\nconst clearTypeExampleValues = () => {\n  typeExampleValues = {}\n  typeConflictReporter.clearConflicts()\n}\n\nconst getNodesAndTypeFromArg = arg => {\n  let type, nodes\n\n  if (_.isPlainObject(arg)) {\n    type = arg.type\n    nodes = arg.nodes\n  } else if (_.isArray(arg)) {\n    nodes = arg\n    if (nodes.length > 0 && nodes[0].internal) {\n      type = nodes[0].internal.type\n    }\n  } else if (_.isString) {\n    type = arg\n  }\n\n  return { type, nodes }\n}\n\nconst getExampleValues = arg => {\n  const { type, nodes } = getNodesAndTypeFromArg(arg)\n\n  // if type is defined and is in example value cache return it\n  if (type && type in typeExampleValues) {\n    return typeExampleValues[type]\n  }\n\n  // if nodes were passed extract field example from it\n  if (nodes && nodes.length > 0) {\n    const exampleValue = extractFieldExamples(nodes, type)\n    // if type is set - cache results\n    if (type) {\n      typeExampleValues[type] = exampleValue\n    }\n    return exampleValue\n  }\n\n  return {}\n}\n\nmodule.exports = {\n  INVALID_VALUE,\n  buildFieldEnumValues,\n  extractFieldNames,\n  isEmptyObjectOrArray,\n  clearTypeExampleValues,\n  getExampleValues,\n}\n"]}